# Santa's Public Key Factory

This challenge was to exploit the weak primes generated to create a RSA public key. The following is the weak prime generation code:

```
  def get_rand_int(self):
        res = 2 ** (self.size - 1)

        for i in range(self.bits):
            if self.rnd.randint(0, 1) == 1:
                res += 2**self.exp[i]

        return res

    def get_prime(self):
        return int(next_prime(self.get_rand_int()))
```

# Solution

We used the `greatest common divisor` algorithm/technique to find common factors between the public keys (`N`) that were generated.  

The public key `N` was generated by two primes `p` and `q`, generated with the code given above. The `self.rnd` is a truely random source, however `self.exp` is an array of 16 randomly chosen values where 32 < value < 1023 holds true. 

Due to the fact the array is only initalised once per connection (or 256 public key generations), it is possible to utilise the birthday problem (https://en.wikipedia.org/wiki/Birthday_problem). Where even with a small set of generations its possible to reach a high probability that two or more share a common prime.

So effectively the pseudo-code for this is as follows:

```
connection = connect()
allKeys = []

while(true) {
    N = connection.getPublicKeyN()
    for K in allKeys {
        factor = GCD(N,K)
        if factor != 1 { // If we actually have a factor, decrypt the message
            p = factor
            q = N/factor
            phi = (p - 1) * (q - 1)
            d = inverse(0x10001, phi) // The 'e' component is static 0x10001 = 65537

            ciphertext = connection.getEncryptedMessage()
            plaintext = pow(ciphertext, d, n)

            connection.send(plaintxt)

            return
        }
    }
}

```
